[{"id":0,"href":"/poutine/rules/untrusted_checkout_exec/","title":"Arbitrary Code Execution from Untrusted Code Changes","parent":"En","content":" Description The workflow appears to checkout untrusted code from a fork and uses a command that is known to allow code execution.\nUsing workflows with pull_request_target has the added benefit (as opposed to pull_request) of allowing access to secrets even in forked repositories. There can be good reasons to do so if you need to use API Keys to talk to some external services or want to interact with the GitHub API with write permissions. However, this comes at the cost of paying extra attention to the tools you use in your workflow.\nSo-called \u0026ldquo;Living Off The Pipeline\u0026rdquo; tools are common development tools (typically CLIs), commonly used in CI/CD pipelines that have lesser-known RCE-By-Design features (\u0026ldquo;foot guns\u0026rdquo;) that can be abused to execute arbitrary code. These tools are often used to automate tasks such as compiling, testing, packaging, linting or scanning. The gotcha comes from the fact that many of those tools will consume unutrusted input from files on disk and when you checkout untrusted code from a fork, you are effectively allowing the attacker to control the input to those tools.\nRemediation GitHub Actions Recommended Using labels Make it mandatory to label the PR with a specific label before the workflow runs. This way, you can ensure that only PRs that are labeled with the specific label are allowed to run the workflow.\nAdding a label to a pull request can only be performed by users with write access to the repository. This means that the attacker would need to have write access to the repository to add the label to the pull request.\nIMPORTANT NOTE: The hypotethical npm run lint command used here, assumes that it will process files in the untrusted directory. If your actual tool is not designed to process files in a specific directory, you should consider using a different approach to prevent code execution.\nThe following example not only checks for the label, but is also coded defensively to run trusted linting scripts, despite needing access to secrets.\non: pull_request_target: branches: [main] types: [labeled] permissions: {} jobs: lint: runs-on: ubuntu-latest if: github.event.label.name == \u0026#39;safe-to-run\u0026#39; permissions: contents: read pull-requests: write steps: - name: Checkout trusted code from protected branch uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1 with: ref: main persist-credentials: false path: trusted - name: Install trusted dependencies working-directory: trusted run: npm ci - name: Checkout untrusted code uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1 with: repository: ${{ github.event.pull_request.head.repo.full_name }} ref: ${{ github.event.pull_request.head.sha }} persist-credentials: false path: untrusted - name: Run linting script on untrusted code id: untrusted-code-lint working-directory: trusted env: LINTING_TOOL_API_KEY: ${{ secrets.LINTING_TOOL_API_KEY }} run: | RAND_DELIMITER=\u0026#34;$(openssl rand -hex 16)\u0026#34; # 128-bit random delimiter token echo \u0026#34;tainted\u0026lt;\u0026lt;${RAND_DELIMITER}\u0026#34; \u0026gt;\u0026gt; \u0026#34;${GITHUB_OUTPUT}\u0026#34; echo \u0026#34;$(npm run lint --ignore-scripts $GITHUB_WORKSPACE/untrusted/)\u0026#34; \u0026gt;\u0026gt; \u0026#34;${GITHUB_OUTPUT}\u0026#34; echo \u0026#34;${RAND_DELIMITER}\u0026#34; \u0026gt;\u0026gt; \u0026#34;${GITHUB_OUTPUT}\u0026#34; - name: Output linting results to Pull Request uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1 env: UNTRUSTED_CODE_TAINTED_LINT_RESULTS: ${{ steps.untrusted-code-lint.outputs.tainted }} with: script: | const { UNTRUSTED_CODE_TAINTED_LINT_RESULTS } = process.env github.rest.issues.createComment({ issue_number: context.issue.number, owner: context.repo.owner, repo: context.repo.repo, body: `ðŸ‘‹ Thanks for your contribution.\\nHere are the linting results:\\n${UNTRUSTED_CODE_TAINTED_LINT_RESULTS}` }) Using environments You should limit the number of simple Actions secrets and prefer the use environments to store secrets to restrict the execution of the workflow to specific environments. This way, you can ensure that only PRs that are targeting the specific environment are allowed to run the workflow. And you can configure the environment to be protected and require approval before the workflow runs.\nIMPORTANT NOTE: The hypotethical npm run lint command used here, assumes that it will process files in the untrusted directory. If your actual tool is not designed to process files in a specific directory, you should consider using a different approach to prevent code execution.\nThe following example is very similar to the previous, but uses environments and stores the LINTING_TOOL_API_KEY in the environment.\non: pull_request_target: branches: [main] types: [opened, synchronize] permissions: {} jobs: lint: runs-on: ubuntu-latest environment: untrusted-pull-request-from-forks permissions: contents: read pull-requests: write steps: - name: Checkout trusted code from protected branch uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1 with: ref: main persist-credentials: false path: trusted - name: Install trusted dependencies working-directory: trusted run: npm ci - name: Checkout untrusted code uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1 with: repository: ${{ github.event.pull_request.head.repo.full_name }} ref: ${{ github.event.pull_request.head.sha }} persist-credentials: false path: untrusted - name: Run linting script on untrusted code id: untrusted-code-lint working-directory: trusted env: LINTING_TOOL_API_KEY: ${{ secrets.LINTING_TOOL_API_KEY }} run: | RAND_DELIMITER=\u0026#34;$(openssl rand -hex 16)\u0026#34; # 128-bit random delimiter token echo \u0026#34;tainted\u0026lt;\u0026lt;${RAND_DELIMITER}\u0026#34; \u0026gt;\u0026gt; \u0026#34;${GITHUB_OUTPUT}\u0026#34; echo \u0026#34;$(npm run lint --ignore-scripts $GITHUB_WORKSPACE/untrusted/)\u0026#34; \u0026gt;\u0026gt; \u0026#34;${GITHUB_OUTPUT}\u0026#34; echo \u0026#34;${RAND_DELIMITER}\u0026#34; \u0026gt;\u0026gt; \u0026#34;${GITHUB_OUTPUT}\u0026#34; - name: Output linting results to Pull Request uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1 env: UNTRUSTED_CODE_TAINTED_LINT_RESULTS: ${{ steps.untrusted-code-lint.outputs.tainted }} with: script: | const { UNTRUSTED_CODE_TAINTED_LINT_RESULTS } = process.env github.rest.issues.createComment({ issue_number: context.issue.number, owner: context.repo.owner, repo: context.repo.repo, body: `ðŸ‘‹ Thanks for your contribution.\\nHere are the linting results:\\n${UNTRUSTED_CODE_TAINTED_LINT_RESULTS}` }) Anti-Pattern This example contains several things that could be improved to make the workflow more secure.\n# (1) Triggers on `pull_request_target`, no scoping to protected branch, no scoping to selected events on: pull_request_target # (2) Using default permissions for automatic token jobs: lint: runs-on: ubuntu-latest # (3) Runs unconditionnally (no label, no environment) steps: - name: Checkout untrusted code uses: actions/checkout@v4 # (4) Missing pinning with: repository: ${{ github.event.pull_request.head.repo.full_name }} ref: ${{ github.event.pull_request.head.sha }} # (5) Persisting credentials is not necessary - Though this is not a panacea, credentials can still be dumped from memory # (6) Checking untrusted code in default workspace path - In this scenario, it\u0026#39;s good to explicitely define the path with untrusted code - name: Install dependencies run: npm install # (7) Should use `npm ci` instead, this will allow attack to install any package - name: Run linting script id: lint env: LINTING_TOOL_API_KEY: ${{ secrets.LINTING_TOOL_API_KEY }} run: | echo \u0026#34;results\u0026lt;\u0026lt;EOF\u0026#34; \u0026gt;\u0026gt; \u0026#34;${GITHUB_OUTPUT}\u0026#34; # (8) Untrusted output could output more that just `results` because EOF delimiter is known to the attacker echo \u0026#34;$(npm run lint)\u0026#34; \u0026gt;\u0026gt; \u0026#34;${GITHUB_OUTPUT}\u0026#34; # (9) RCE-by-design (npm will consume untrusted `package.json` and execute arbitrary code) echo \u0026#34;EOF\u0026#34; \u0026gt;\u0026gt; \u0026#34;${GITHUB_OUTPUT}\u0026#34; - name: Output linting results to Pull Request uses: actions/github-script@v7 # (10) Missing pinning with: script: | github.rest.issues.createComment({ issue_number: context.issue.number, owner: context.repo.owner, repo: context.repo.repo, body: `ðŸ‘‹ Thanks for your contribution.\\nHere are the linting results:\\n${{ steps.lint.outputs.results }}` // (11) Second-order Injection }) See Also Keeping your GitHub Actions and workflows secure Part 1: Preventing pwn requests Erosion of Trust: Unmasking Supply Chain Vulnerabilities in the Terraform Registry The tale of a Supply Chain near-miss incident Living Off The Pipeline ","description":"Description The workflow appears to checkout untrusted code from a fork and uses a command that is known to allow code execution.\nUsing workflows with pull_request_target has the added benefit (as opposed to pull_request) of allowing access to secrets even in forked repositories. There can be good reasons to do so if you need to use API Keys to talk to some external services or want to interact with the GitHub API with write permissions."},{"id":1,"href":"/poutine/rules/known_vulnerability/","title":"CI Component with a Known Vulnerability used","parent":"En","content":" Description A CI component was found to be vulnerable to a publicly known security vulnerability from the Open Source Vulnerability Database (OSV)\nGitHub Actions GitHub Actions workflows using third-party GitHub Actions with known vulnerabilities could compromise the security of the workflow and the repository.\nRemmediation Upgrade the affected component to a non-vulnerable version or remove the component from the workflow.\nSee Also GitHub Docs: Keeping your actions up to date with Dependabot GitHub Docs: Exporting a software bill of materials for your repository ","description":" Description A CI component was found to be vulnerable to a publicly known security vulnerability from the Open Source Vulnerability Database (OSV)\nGitHub Actions GitHub Actions workflows using third-party GitHub Actions with known vulnerabilities could compromise the security of the workflow and the repository.\nRemmediation Upgrade the affected component to a non-vulnerable version or remove the component from the workflow.\nSee Also GitHub Docs: Keeping your actions up to date with Dependabot GitHub Docs: Exporting a software bill of materials for your repository "},{"id":2,"href":"/poutine/rules/debug_enabled/","title":"CI Debug Enabled","parent":"En","content":" Description The workflow is configured to increase the verbosity of the runner. This can potentially expose sensitive information.\nRemediation Gitlab CI In the workflow file, remove the CI_DEBUG_TRACE or CI_DEBUG_SERVICES variable in the job definition or set to false.\nRecommended job_name: variables: CI_DEBUG_TRACE: \u0026#34;false\u0026#34; # Or, better, simply omit those variables as they default to `false` anyway. CI_DEBUG_SERVICES: \u0026#34;false\u0026#34; Anti-Pattern job_name: variables: CI_DEBUG_TRACE: \u0026#34;true\u0026#34; CI_DEBUG_SERVICES: \u0026#34;true\u0026#34; See Also https://docs.gitlab.com/ee/ci/variables/index.html#enable-debug-logging https://docs.gitlab.com/ee/ci/variables/index.html#mask-a-cicd-variable ","description":"Description The workflow is configured to increase the verbosity of the runner. This can potentially expose sensitive information.\nRemediation Gitlab CI In the workflow file, remove the CI_DEBUG_TRACE or CI_DEBUG_SERVICES variable in the job definition or set to false.\nRecommended job_name: variables: CI_DEBUG_TRACE: \u0026#34;false\u0026#34; # Or, better, simply omit those variables as they default to `false` anyway. CI_DEBUG_SERVICES: \u0026#34;false\u0026#34; Anti-Pattern job_name: variables: CI_DEBUG_TRACE: \u0026#34;true\u0026#34; CI_DEBUG_SERVICES: \u0026#34;true\u0026#34; See Also https://docs.gitlab.com/ee/ci/variables/index.html#enable-debug-logging https://docs."},{"id":3,"href":"/poutine/rules/default_permissions_on_risky_events/","title":"Default permissions used on risky events","parent":"En","content":" Description If a GitHub Actions workflow does not declare permissions for its job, it inherits the default permissions configured in the GitHub Actions settings of the repository. For organizations created before February 2023, which is the case for a large number of important OSS projects and corporations, the default permissions used to grant read-write access to the repository and even new repositories will inherit the permissions of the old, insecure defaults from the organization.\nWorkflows that trigger on events often related to pull requests from forks (pull_request_target, issue_comment) should ensure all jobs run with the minimum required permissions. This helps to ensure the workflow does not inadvertently expose a privileged token to untrusted code regardless of the default permissions set in the repository.\nRemediation In the affected worfklows, ensure that permissions are explicitely declared at the workflow level or at each job level.\nThe default workflow permissions can be configured to have no permissions to ensure that all jobs declare their permissions.\non: pull_request_target: branches: [main] types: [opened, synchronized] permissions: {} # Change the default job permissions to none jobs: pr-read: runs-on: ubuntu-latest permissions: contents: read steps: - uses: actions/checkout@v4 When using workflow level permissions, ensure that the permissions are set to the minimum required for the workflow to function correctly. Increase the permissions only if necessary on a per-job basis.\non: pull_request_target: branches: [main] types: [opened, synchronized] permissions: contents: read jobs: pr-read: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 issues-write: runs-on: ubuntu-latest permissions: issues: write steps: - uses: org/create-issue-action@v2 Anti-Pattern on: pull_request_target jobs: build-pr: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 with: ref: ${{ github.event.pull_request.head.ref }} - run: make See Also GitHub Actions: Assigning permissions to jobs GitHub Actions: Setting the permissions of the GITHUB_TOKEN for your repository ","description":"Description If a GitHub Actions workflow does not declare permissions for its job, it inherits the default permissions configured in the GitHub Actions settings of the repository. For organizations created before February 2023, which is the case for a large number of important OSS projects and corporations, the default permissions used to grant read-write access to the repository and even new repositories will inherit the permissions of the old, insecure defaults from the organization."},{"id":4,"href":"/poutine/en/","title":"En","parent":"poutine","content":"","description":""},{"id":5,"href":"/poutine/rules/github_action_from_unverified_creator_used/","title":"Github Action from Unverified Creator used","parent":"En","content":" Description Usage of the following GitHub Actions repositories was detected in workflows or composite actions, but their owner is not a verified creator.\nRemediation In the workflow file, replace the action with a verified creator\u0026rsquo;s action if possible. Verified creators can be found in the GitHub Marketplace.\nEven if the action is published by a Verified Creator, it should not imply that the action is secure or still maintained. A popular action (with many stars and/or downloads) neither implies that it is safe.\nRunning poutine against the org / repo where the action is published can help you in your own risk analysis.\nSee Also Actions published by Verified Creators on the GitHub Actions Marketplace About badges in GitHub Marketplace ","description":"Description Usage of the following GitHub Actions repositories was detected in workflows or composite actions, but their owner is not a verified creator.\nRemediation In the workflow file, replace the action with a verified creator\u0026rsquo;s action if possible. Verified creators can be found in the GitHub Marketplace.\nEven if the action is published by a Verified Creator, it should not imply that the action is secure or still maintained. A popular action (with many stars and/or downloads) neither implies that it is safe."},{"id":6,"href":"/poutine/rules/if_always_true/","title":"If condition always evaluates to true","parent":"En","content":" Description GitHub Actions expressions used in if condition of jobs or steps must not contain extra characters or spaces. Otherwise, the condition is always evaluated to true.\nThis can lead to logic bugs and possibly expose parts of the workflow only meant to be executed in secure contexts.\nRemediation Recommended name: Conditionally process PR on: pull_request_target: types: [opened, synchronize, reopened] jobs: process-pr: runs-on: ubuntu-latest steps: - name: Auto-format markdown files if: github.actor == \u0026#39;torvalds\u0026#39; || github.actor == \u0026#39;dependabot[bot]\u0026#39; uses: messypoutine/actionable/.github/actions/auto-format@0108c4ec935a308435e665a0e9c2d1bf91e25685 # v1.0.0 Anti-Pattern name: Conditionally process PR on: pull_request_target: types: [opened, synchronize, reopened] jobs: process-pr: runs-on: ubuntu-latest steps: - name: Auto-format markdown files if: | ${{ github.actor == \u0026#39;torvalds\u0026#39; || github.actor == \u0026#39;dependabot[bot]\u0026#39; }} uses: messypoutine/actionable/.github/actions/auto-format@0108c4ec935a308435e665a0e9c2d1bf91e25685 # v1.0.0 See Also Expression Always True Github Issue About expressions jobs\u0026lt;job_id\u0026gt;.if ","description":"Description GitHub Actions expressions used in if condition of jobs or steps must not contain extra characters or spaces. Otherwise, the condition is always evaluated to true.\nThis can lead to logic bugs and possibly expose parts of the workflow only meant to be executed in secure contexts.\nRemediation Recommended name: Conditionally process PR on: pull_request_target: types: [opened, synchronize, reopened] jobs: process-pr: runs-on: ubuntu-latest steps: - name: Auto-format markdown files if: github."},{"id":7,"href":"/poutine/rules/injection/","title":"Injection with Arbitrary External Contributor Input","parent":"En","content":" Description The pipeline contains an injection into bash or JavaScript with an expression that can contain user input. Prefer placing the expression in an environment variable instead of interpolating it directly into a script.\nRemediation GitHub Actions Recommended on: pull_request_target: branches: [main] types: [opened, synchronize] permissions: {} jobs: lint: runs-on: ubuntu-latest permissions: pull-requests: write steps: - name: Validate pull request title and body uses: actions/github-script@v60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1 env: PR_TITLE: ${{ github.event.pull_request.title }} with: script: | const { PR_TITLE } = process.env github.rest.issues.createComment({ issue_number: context.issue.number, owner: context.repo.owner, repo: context.repo.repo, body: `Your title (${PR_TITLE}) must match our expected format (\u0026#34;BUG: Fix this now!!!\u0026#34;).` }) Anti-Pattern # (1) Triggers on `pull_request_target`, no scoping to protected branch, no scoping to selected events on: pull_request_target permissions: write-all # (2) Unnecessary permissions jobs: lint: runs-on: ubuntu-latest steps: - name: Debug run: | # (3) Bash injection echo \u0026#34;Title: ${{ github.event.pull_request.title }}\u0026#34; echo \u0026#34;Body: ${{ github.event.pull_request.body }}\u0026#34; - name: Validate pull request title and body uses: actions/github-script@v7 # (4) Missing pinning with: script: | // (5) JavaScript injection github.rest.issues.createComment({ issue_number: context.issue.number, owner: context.repo.owner, repo: context.repo.repo, body: \u0026#34;Your title (${{ github.event.pull_request.title}}) must match the expected format.\u0026#34; }) See Also Understanding the risk of script injections Good practices for mitigating script injection attacks ","description":"Description The pipeline contains an injection into bash or JavaScript with an expression that can contain user input. Prefer placing the expression in an environment variable instead of interpolating it directly into a script.\nRemediation GitHub Actions Recommended on: pull_request_target: branches: [main] types: [opened, synchronize] permissions: {} jobs: lint: runs-on: ubuntu-latest permissions: pull-requests: write steps: - name: Validate pull request title and body uses: actions/github-script@v60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1 env: PR_TITLE: ${{ github."},{"id":8,"href":"/poutine/rules/job_all_secrets/","title":"Job uses all secrets","parent":"En","content":" Description A GitHub Actions job was found to have access to all secrets. This may be unnecessary and expose sensitive information to the job.\nThis can occur when the secrets object is serialized to JSON. For example:\nenv: ALL_SECRETS: ${{ toJSON(secrets) }} Accessing the secrets object using a dynamic key will also expose all secrets to the job. For example:\nstrategy: matrix: env: [PROD, DEV] env: GH_TOKEN: ${{ secrets[format(\u0026#39;GH_PAT_%s\u0026#39;, matrix.env)] }} In this example, both secrets GH_PAT_DEV and GH_PAT_PROD are made available in each job as the GitHub Actions runner is unable to determine the secrets the job requires. As a result, all repository and organization secrets are retained in memory and may be accessed by the job.\nRemediation Avoid using ${{ toJSON(secrets) }} or ${{ secrets[...] }} and only reference individual secrets that are required for the job.\nTo avoid dynamic key access, consider using GitHub Actions environments to restrict the secrets available to the job. This way, the secrets can share the same name, but have different values based on the environment the job uses. Additionally, GitHub Actions environments can benefit from deployment protections rules to further restrict the access to its secrets. The previous matrix workflow can be rewritten as follows:\nbuild: runs-on: ubuntu-latest strategy: matrix: env: [PROD, DEV] environment: ${{ matrix.env }} env: GH_TOKEN: ${{ secrets.GH_PAT }} See Also GitHub Actions: Using environments for jobs GitHub Actions: Deployment protection rules Leaking Secrets From GitHub Actions: Reading Files And Environment Variables, Intercepting Network/Process Communication, Dumping Memory ","description":"Description A GitHub Actions job was found to have access to all secrets. This may be unnecessary and expose sensitive information to the job.\nThis can occur when the secrets object is serialized to JSON. For example:\nenv: ALL_SECRETS: ${{ toJSON(secrets) }} Accessing the secrets object using a dynamic key will also expose all secrets to the job. For example:\nstrategy: matrix: env: [PROD, DEV] env: GH_TOKEN: ${{ secrets[format(\u0026#39;GH_PAT_%s\u0026#39;, matrix."},{"id":9,"href":"/poutine/","title":"poutine","parent":"","content":"This is the documentation for the poutine project.\n","description":"This is the documentation for the poutine project."},{"id":10,"href":"/poutine/rules/pr_runs_on_self_hosted/","title":"Pull Request Runs on Self-Hosted GitHub Actions Runner","parent":"En","content":" Description This job runs on a self-hosted GitHub Actions runner in a workflow that is triggered by a pull_request event (or other Pull Request related events). Using self-hosted runners in Public repositories, especially when processing events for pull_request events is considered highly risky as it allows external threats to run arbitrary code on that self-hosted runner compute instance.\nWhile the \u0026ldquo;Maximum access for pull requests from public forked repositories\u0026rdquo; is read, meaning that secrets (either repo-level or organization-level) are not exposed immediately accessible to the pull request workflow, the attacker can still directly run arbitrary code, without leveraging any vulnerability. Then, if they can perform privilege escalation (most runners allow sudo), they may exfiltrate sensitive information from the runner, especially if the runner does not properly reset its state between jobs.\nThis risk occurs as soon as your GitHub Organization sets the GitHub Actions Runners configuration to allow self-hosted runners to be used in public repositories. You don\u0026rsquo;t even need to have a workflow that explicitly uses a self-hosted runner in a public repository, the mere fact that the configuration allows it is enough to allow the attacker to exploit it.\nAt the moment, poutine looks for evidence of workflows explicitely using self-hosted runners, but we plan on improving this detection to also include the configuration of the GitHub Organization.\nRemediation GitHub Actions Recommended Set GitHub Organization Runners configuration to Disabled.\nIf you decide to allow and use self-hosted runners in public repositories, make sure to follow the hardening guidelines, knowing that is it critical to ensure that the runner is properly isolated from the rest of your infrastructure and state is cleared between jobs.\nAnti-Pattern Having a GitHub Organization Runners configuration set to All repositories or to select some public repositories comes with the added responsbility of configuring your self-hosted runners pool in a way that is safe.\nSee Also Self-hosted runner security Hardening for self-hosted runners Playing with fire - How we executed a critical supply chain attack on pytorch TensorFlow Supply Chain Compromise via Self-Hosted Runner Attack Gato - Github Attack TOOlkit ","description":"Description This job runs on a self-hosted GitHub Actions runner in a workflow that is triggered by a pull_request event (or other Pull Request related events). Using self-hosted runners in Public repositories, especially when processing events for pull_request events is considered highly risky as it allows external threats to run arbitrary code on that self-hosted runner compute instance.\nWhile the \u0026ldquo;Maximum access for pull requests from public forked repositories\u0026rdquo; is read, meaning that secrets (either repo-level or organization-level) are not exposed immediately accessible to the pull request workflow, the attacker can still directly run arbitrary code, without leveraging any vulnerability."},{"id":11,"href":"/poutine/tags/","title":"Tags","parent":"poutine","content":"","description":""},{"id":12,"href":"/poutine/rules/unpinnable_action/","title":"Unpinnable CI component used","parent":"En","content":" Description The rule identifies CI components that are unpinnable (often seen in the context of \u0026ldquo;composite\u0026rdquo; GitHub Actions), because they depend on mutable supply chain components. Pinning using a cryptographic hash or signature is considered a Best Practice to ensure that a specific version of a component is used, which can help in making builds more reproducible and trustworthy. However, if a component, such as a GitHub Action, is architected in a way that depends on other components, which can be compromised, pinning it does not effectively mitigate the risks associated with mutable supply chain components.\nIt is critical to keep in mind that the same logic applies to the dependencies of the dependencies. You must validate that those transitive dependencies are also pinned! Even if those components are pinned, they might dynamically load other components at runtime (like with curl | bash) or have an injection vulnerability. Pinning is NOT a silver bullet, but it is step in the right direction.\nRemediation GitHub Actions Unfortunately, there is no easy way to mitigate the risks associated with unpinnable GitHub Actions, since this a risk inherited from the way the action you are using is designed.\nYou can do one of the following:\nFind an alternative action that is pinnable You can fork the action and pin the downstream components yourself You can file a bug report with the maintainer of the action to request that they make it pinnable Composite Actions Recommended pattern action.yml\nruns: using: composite steps: - uses: someorg/some-action@8de4be516879302afce542ac80a6a43ced807759 # v3.1.2 with: some-input: some-value Anti-Pattern action.yml\nruns: using: composite steps: - uses: someorg/some-action@v3 with: some-input: some-value Docker-based Actions (remote image) Recommended pattern action.yml\nruns: using: docker image: docker://ghcr.io/some-org/some-docker@sha256:8de4be516879302afce542ac80a6a43ced807759 # v6.3.1 Anti-Pattern action.yml\nruns: using: docker image: docker://ghcr.io/some-org/some-docker:v6.3.1 Docker-based Actions (Dockerfile) Recommended pattern action.yml\nruns: using: docker image: Dockerfile Dockerfile\nFROM: ghcr.io/some-org/some-docker@sha256:8de4be516879302afce542ac80a6a43ced807759 # v6.3.1 Anti-Pattern action.yml\nruns: using: docker image: Dockerfile Dockerfile\nFROM: ghcr.io/some-org/some-docker:v6.3.1 See Also Unpinnable Actions: How Malicious Code Can Sneak into Your GitHub Actions Workflows Pinning Dependencies to a Specific Hash ","description":"Description The rule identifies CI components that are unpinnable (often seen in the context of \u0026ldquo;composite\u0026rdquo; GitHub Actions), because they depend on mutable supply chain components. Pinning using a cryptographic hash or signature is considered a Best Practice to ensure that a specific version of a component is used, which can help in making builds more reproducible and trustworthy. However, if a component, such as a GitHub Action, is architected in a way that depends on other components, which can be compromised, pinning it does not effectively mitigate the risks associated with mutable supply chain components."}]